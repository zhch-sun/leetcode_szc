#
# @lc app=leetcode id=924 lang=python
#
# [924] Minimize Malware Spread
#

# @lc code=start
from collections import Counter

class UF(object):
    def __init__(self, N):
        self.fa = list(range(N))
        self.sz = [1] * N

    def find(self, p):
        if self.fa[p] != p:
            self.fa[p] = self.find(self.fa[p])
        return self.fa[p]

    def union(self, p, q):
        pRoot = self.find(p)
        qRoot = self.find(q)
        if pRoot == qRoot:
            return
        if self.sz[pRoot] < self.sz[qRoot]:
            self.fa[pRoot] = qRoot  # Note所有索引都是root!!!
            self.sz[qRoot] += self.sz[pRoot]
        else:  # Note所有索引都是root!!!
            self.fa[qRoot] = p
            self.sz[pRoot] += self.sz[qRoot]
            
class Solution(object):
    def minMalwareSpread(self, graph, initial):
        """
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        """            
        N = len(graph)
        uf = UF(N)
        for i in xrange(N):
            for j in xrange(N):  # 可以上三角!
                if graph[i][j]:
                    uf.union(i, j)
        cnt = Counter()  # 先计算这个! group: cnt
        for node in initial:
            cnt[uf.find(node)] += 1
        ans = (-1, float('-inf'))
        for node in initial:
            if cnt[uf.find(node)] == 1:
                num = uf.sz[uf.find(node)]
                if num > ans[1] or num == ans[1] \
                    and node < ans[0]:  # 还有num值相等的情况
                    ans = [node, num]
        if ans[0] == -1:
            return min(initial)
        else:
            return ans[0]

    # def minMalwareSpread(self, graph, initial):
    #     def dfs(i, gidx):
    #         seen[i] = gidx
    #         cnt = 1
    #         for j in xrange(N):
    #             if not seen[j] and graph[i][j]:
    #                 cnt += dfs(j, gidx)
    #         return cnt

    #     N = len(graph)
    #     seen = [False] * N
    #     gidx = 1
    #     gcnt = [0]
    #     for i in xrange(N):
    #         if not seen[i]:
    #             gcnt.append(dfs(i, gidx))
    #             gidx += 1  # 忘记了...

    #     # find the min value
    #     ccnt = Counter()  # color cnt
    #     for i in initial:
    #         ccnt[seen[i]] += 1
        
    #     ans = [-1, float('-inf')]
    #     for node in initial:  # 循环node而不是ccnt
    #         cnum = ccnt[seen[node]]  # cnum和gnum太容易混淆..
    #         if cnum == 1:  # the unique
    #             gnum = gcnt[seen[node]]
    #             if  gnum > ans[1]:  # 不是num>ans[1]..
    #                 ans = [node, gnum]
    #             elif gcnt[seen[node]] == ans[1] and node < ans[0]:
    #                 ans = [node, gnum]  # Note 这里还有个赋值..
    #     if ans[0] == -1:
    #         return min(initial)  
    #     else:
    #         return ans[0]
        


if __name__ == '__main__':
    """
    题设: 
        给出邻接矩阵. 返回索引. 多个解得时候, 返回数字最小的. 
    解法1:
        并查集清晰很多. 后处理需要先计算每个group的出现次数.
        然后再循环initial, 当出现一次的时候才参与比较.
        然后还有num相同的逻辑..      
    解法2:   
        dfs比较麻烦. 
        需要seen表示是否经过, 需要group_idx表示当前是第几个group.
        需要group_cnt表示每个group的数量. 
        需要ccnt表示initial中每个node的重复情况..
        sub里面有更简单的写法, 不管了.....

    """
    s = Solution()
    # print(s.minMalwareSpread([[1,1,0],[1,1,0],[0,0,1]], [0,1]))
    # print(s.minMalwareSpread([[1,0,0],[0,1,0],[0,0,1]], [0,2]))
    # print(s.minMalwareSpread([[1,1,1],[1,1,1],[1,1,1]], [1,2]))
    # print(s.minMalwareSpread([[1,0,0,0],[0,1,0,0],[0,0,1,1],[0,0,1,1]], [3,1]))
    # print(s.minMalwareSpread([[1,0,0,0,0,0],[0,1,0,0,0,0],[0,0,1,0,0,0],[0,0,0,1,1,0],[0,0,0,1,1,0],[0,0,0,0,0,1]], [5,0]))
    print(s.minMalwareSpread([[1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0],[0,1,1,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0,0,0],[1,0,0,0,1,0,0,0,0,0],[0,0,1,0,0,1,0,0,0,0],[0,0,0,0,0,0,1,0,0,1],[0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,1,0,0,1]], [1,3,0]))
    
# @lc code=end

